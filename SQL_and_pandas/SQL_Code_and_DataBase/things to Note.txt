{
    The Best Practice (This is the rule you should follow) Your code is read 10x more than it is written. The goal of formatting is readability.

    RULE 1: SQL Keywords are UPPERCASE

    This includes SELECT, FROM, WHERE, GROUP BY, ORDER BY, AS, LIMIT, JOIN, ON.

    RULE 2: Your Identifiers are lowercase or snake_case

    This includes your table names (employees, sales) and your column names (first_name, salary).
},

{
    The WHERE clause comes after FROM but before GROUP BY or ORDER BY.

    Comparison Operators: These are the standard math operators.

    = (Equal to)

    != or <> (Not equal to)

    > (Greater than)

    < (Less than)

    >= (Greater than or equal to)

    <= (Less than or equal to)
},

{
    "Any column in your SELECT list that is NOT an aggregate function (SUM, AVG, COUNT...) MUST be listed in your GROUP BY clause."

    Why? Think about it. If you ask for SELECT Store, Product, SUM(Sales) ... GROUP BY Store... The query is trying to return one row for 'Store_A' with one SUM (e.g., $10,000). But 'Store_A' has 5 different products ('Apples', 'Oranges', etc.). The database gets confused. It can't show you one row for 'Store_A' and five different product names.

    The Fix: If you want to see Store and Product, you must tell the database to group by both: GROUP BY Store, Product. This will give you the SUM for (Store_A, Apples), (Store_A, Oranges), etc.
},

{
    If you are filtering on an aggregate function (like SUM(Sales) or COUNT(*)), you MUST use HAVING
},


{
    How to stop and start postgreSQL server:
    - Stop:
    sudo systemctl stop postgresql

    - Start:
    sudo systemctl start postgresql
},

{
    The Goal of Normalization
    The goal is "One Fact, One Place." If you change a user's email address, you should only have to update one row in your entire database. If you have to update 50 rows, your database is "Un-Normalized" and you are going to have bugs.

    1. First Normal Form (1NF): The "Atomic" Rule
    Rule: No lists in a single cell. One value per cell.

    2. Second Normal Form (2NF): The "Whole Key" Rule
    Rule: Every column must depend on the Entire Primary Key, not just part of it. Note: This only applies if you have a "Composite Key" (an ID made of two columns combined).

    3. Third Normal Form (3NF): The "No Chain Reaction" Rule
    Rule: Columns shouldn't depend on other non-key columns. (Transitive Dependency).
}



